import { prisma } from './prisma'

/**
 * Auto-sync service for keeping data synchronized
 * This service handles:
 * - Auto-updating booking statuses (expired bookings)
 * - Auto-cancelling conflicting bookings
 * - Syncing statistics
 * - Cleaning up old data
 */

export async function syncBookings() {
  try {
    const now = new Date()
    
    // Auto-cancel expired pending bookings
    const expiredBookings = await prisma.culturalCenterBooking.findMany({
      where: {
        status: 'PENDING',
        startTime: { lt: now }
      }
    })

    for (const booking of expiredBookings) {
      await prisma.culturalCenterBooking.update({
        where: { id: booking.id },
        data: {
          status: 'REJECTED',
          autoCancelled: true,
          rejectionReason: 'Tự động hủy do quá hạn',
          lastSyncedAt: now
        }
      })

      // Notify user
      await prisma.notification.create({
        data: {
          title: 'Lịch đặt đã bị hủy',
          message: `Lịch đặt "${booking.title}" đã bị tự động hủy do quá hạn.`,
          userId: booking.userId,
          type: 'WARNING',
          autoGenerated: true
        }
      })
    }

    // Check for conflicting approved bookings and auto-cancel newer ones
    const allBookings = await prisma.culturalCenterBooking.findMany({
      where: {
        status: 'APPROVED',
        startTime: { gte: now }
      },
      orderBy: {
        createdAt: 'asc'
      }
    })

    let conflictsResolved = 0
    for (let i = 0; i < allBookings.length; i++) {
      const booking = allBookings[i]
      const conflicts = allBookings.filter((b, idx) => 
        idx > i &&
        b.culturalCenterId === booking.culturalCenterId &&
        b.id !== booking.id &&
        (
          (b.startTime >= booking.startTime && b.startTime < booking.endTime) ||
          (b.endTime > booking.startTime && b.endTime <= booking.endTime) ||
          (b.startTime <= booking.startTime && b.endTime >= booking.endTime)
        )
      )

      for (const conflict of conflicts) {
        await prisma.culturalCenterBooking.update({
          where: { id: conflict.id },
          data: {
            status: 'REJECTED',
            autoCancelled: true,
            rejectionReason: 'Tự động hủy do xung đột với lịch đặt khác',
            lastSyncedAt: now
          }
        })

        await prisma.notification.create({
          data: {
            title: 'Lịch đặt bị hủy do xung đột',
            message: `Lịch đặt "${conflict.title}" đã bị tự động hủy do xung đột với lịch đặt khác.`,
            userId: conflict.userId,
            type: 'WARNING',
            autoGenerated: true
          }
        })
        conflictsResolved++
      }
    }

    return { 
      expiredCancelled: expiredBookings.length,
      conflictsResolved 
    }
  } catch (error) {
    console.error('Error syncing bookings:', error)
    throw error
  }
}

export async function syncStatistics() {
  try {
    const now = new Date()
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())

    const [
      totalHouseholds,
      totalPersons,
      totalBookings,
      activeBookings,
      pendingRequests,
      approvedRequests,
      rejectedRequests
    ] = await Promise.all([
      prisma.household.count(),
      prisma.person.count(),
      prisma.culturalCenterBooking.count(),
      prisma.culturalCenterBooking.count({
        where: {
          status: 'APPROVED',
          startTime: { gte: now }
        }
      }),
      prisma.request.count({
        where: { status: 'PENDING' }
      }),
      prisma.request.count({
        where: { status: 'APPROVED' }
      }),
      prisma.request.count({
        where: { status: 'REJECTED' }
      })
    ])

    // Upsert today's statistics
    await prisma.systemStats.upsert({
      where: { date: today },
      update: {
        totalHouseholds,
        totalPersons,
        totalBookings,
        activeBookings,
        pendingRequests,
        approvedRequests,
        rejectedRequests,
        lastSyncedAt: now
      },
      create: {
        date: today,
        totalHouseholds,
        totalPersons,
        totalBookings,
        activeBookings,
        pendingRequests,
        approvedRequests,
        rejectedRequests,
        lastSyncedAt: now
      }
    })

    return {
      totalHouseholds,
      totalPersons,
      totalBookings,
      activeBookings,
      pendingRequests,
      approvedRequests,
      rejectedRequests
    }
  } catch (error) {
    console.error('Error syncing statistics:', error)
    throw error
  }
}

export async function syncAll() {
  try {
    const [bookingSync, stats] = await Promise.all([
      syncBookings(),
      syncStatistics()
    ])

    return {
      bookings: bookingSync,
      statistics: stats,
      syncedAt: new Date()
    }
  } catch (error) {
    console.error('Error in full sync:', error)
    throw error
  }
}

